webpackJsonp([50], {1522: function (t, e, n) { 'use strict'; var o = n(1523); e.a = o.a },
    1523: function (t, e, n) { 'use strict'; var o = n(66), a = n.n(o), i = n(2155), r = n.n(i), s = function (t, e, n) { return r.a.create(t, a()({}, e, {onEnd: function (t) { var e = n.componentInstance.$data.tags, o = e[t.oldIndex]; if (t.newIndex > t.oldIndex) for (var a = t.oldIndex; a < t.newIndex; a++)e[a] = e[a + 1]; else for (var i = t.oldIndex; i > t.newIndex; i--)e[i] = e[i - 1]; e[t.newIndex] = o, n.componentInstance.$emit('input', e), n.context.$buefy.toast.open('Moved ' + o + ' from row ' + (t.oldIndex + 1) + ' to ' + (t.newIndex + 1)) }})) }, l = {name: 'sortable', bind: function (t, e, n) { var o = t.querySelector('.taginput-container'); o._sortable = s(o, e.value, n) }, update: function (t, e, n) { var o = t.querySelector('.taginput-container'); o._sortable.destroy(), o._sortable = s(o, e.value, n) }, unbind: function (t) { t.querySelector('.taginput-container')._sortable.destroy() }}; e.a = {directives: {sortable: l}, data: function () { return {sortableOptions: {chosenClass: 'is-primary', draggable: '.tag'}, tags: ['Pizza', 'Ice cream', 'Cake']} }} },
    1524: function (t, e, n) { var o = n(2157); typeof o === 'string' && (o = [[t.i, o, '']]), o.locals && (t.exports = o.locals); n(1140)('65cfb0d4', o, !0) },
    2153: function (t, e, n) { 'use strict'; var o = n(2154); n.d(e, 'a', function () { return o.a }), n.d(e, 'b', function () { return o.b }) },
    2154: function (t, e, n) { 'use strict'; n.d(e, 'a', function () { return o }), n.d(e, 'b', function () { return a }); var o = function () { var t = this, e = t.$createElement, n = t._self._c || e; return n('section', [n('b-field', {attrs: {label: "What's your favourite food?"}}, [n('b-taginput', {directives: [{name: 'sortable', rawName: 'v-sortable', value: t.sortableOptions, expression: 'sortableOptions'}], staticClass: 'taginput-sortable', attrs: {ellipsis: '', icon: 'label', placeholder: 'Add a food'}, model: {value: t.tags, callback: function (e) { t.tags = e }, expression: 'tags'}})], 1), n('p', {staticClass: 'content'}, [n('b', [t._v('Tags:')]), t._v(' ' + t._s(t.tags))])], 1) }, a = [] },
    2155: function (t, e, n) {
        var o, a
        /** !
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */
        /** !
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */
        !(function (i) { 'use strict'; void 0 === (a = typeof (o = i) === 'function' ? o.call(e, n, e, t) : o) || (t.exports = a) }(function () { 'use strict'; if (typeof window === 'undefined' || !window.document) return function () { throw new Error('Sortable.js requires a window with a document') }; var t, e, n, o, a, i, r, s, l, c, d, u, p, h, f, g, v, m, b, _, y, D = {}, w = /\s+/g, x = /left|right|inline/, S = 'Sortable' + (new Date()).getTime(), C = window, T = C.document, E = C.parseInt, I = C.setTimeout, k = C.jQuery || C.Zepto, N = C.Polymer, A = !1, O = 'draggable' in T.createElement('div'), B = !navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie)/i) && ((y = T.createElement('x')).style.cssText = 'pointer-events:auto', y.style.pointerEvents === 'auto'), P = !1, Y = Math.abs, X = Math.min, M = [], R = [], j = ot(function (t, e, n) { if (n && e.scroll) { var o, a, i, r, d, u, p = n[S], h = e.scrollSensitivity, f = e.scrollSpeed, g = t.clientX, v = t.clientY, m = window.innerWidth, b = window.innerHeight; if (l !== n && (s = e.scroll, l = n, c = e.scrollFn, !0 === s)) { s = n; do { if (s.offsetWidth < s.scrollWidth || s.offsetHeight < s.scrollHeight) break } while (s = s.parentNode) }s && (o = s, a = s.getBoundingClientRect(), i = (Y(a.right - g) <= h) - (Y(a.left - g) <= h), r = (Y(a.bottom - v) <= h) - (Y(a.top - v) <= h)), i || r || (r = (b - v <= h) - (v <= h), ((i = (m - g <= h) - (g <= h)) || r) && (o = C)), D.vx === i && D.vy === r && D.el === o || (D.el = o, D.vx = i, D.vy = r, clearInterval(D.pid), o && (D.pid = setInterval(function () { if (u = r ? r * f : 0, d = i ? i * f : 0, typeof c === 'function') return c.call(p, d, u, t); o === C ? C.scrollTo(C.pageXOffset + d, C.pageYOffset + u) : (o.scrollTop += u, o.scrollLeft += d) }, 24))) } }, 30), $ = function (t) { function e(t, e) { return void 0 !== t && !0 !== t || (t = n.name), typeof t === 'function' ? t : function (n, o) { var a = o.options.group.name; return e ? t : t && (t.join ? t.indexOf(a) > -1 : a == t) } } var n = {}, o = t.group; o && typeof o === 'object' || (o = {name: o}), n.name = o.name, n.checkPull = e(o.pull, !0), n.checkPut = e(o.put), n.revertClone = o.revertClone, t.group = n }; try { window.addEventListener('test', null, Object.defineProperty({}, 'passive', {get: function () { A = {capture: !1, passive: !1} }})) } catch (t) {} function q(t, e) { if (!t || !t.nodeType || t.nodeType !== 1) throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(t); this.el = t, this.options = e = at({}, e), t[S] = this; var n = {group: Math.random(), sort: !0, disabled: !1, store: null, handle: null, scroll: !0, scrollSensitivity: 30, scrollSpeed: 10, draggable: /[uo]l/i.test(t.nodeName) ? 'li' : '>*', ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen', dragClass: 'sortable-drag', ignore: 'a, img', filter: null, preventOnFilter: !0, animation: 0, setData: function (t, e) { t.setData('Text', e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: 'data-id', delay: 0, forceFallback: !1, fallbackClass: 'sortable-fallback', fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: {x: 0, y: 0}, supportPointer: !1 !== q.supportPointer}; for (var o in n)!(o in e) && (e[o] = n[o]); for (var a in $(e), this)a.charAt(0) === '_' && typeof this[a] === 'function' && (this[a] = this[a].bind(this)); this.nativeDraggable = !e.forceFallback && O, U(t, 'mousedown', this._onTapStart), U(t, 'touchstart', this._onTapStart), e.supportPointer && U(t, 'pointerdown', this._onTapStart), this.nativeDraggable && (U(t, 'dragover', this), U(t, 'dragenter', this)), R.push(this._onDragOver), e.store && this.sort(e.store.get(this)) } function F(e, n) { e.lastPullMode !== 'clone' && (n = !0), o && o.state !== n && (V(o, 'display', n ? 'none' : ''), n || o.state && (e.options.group.revertClone ? (a.insertBefore(o, i), e._animate(t, o)) : a.insertBefore(o, t)), o.state = n) } function L(t, e, n) { if (t) { n = n || T; do { if (e === '>*' && t.parentNode === n || nt(t, e)) return t } while (t = W(t)) } return null } function W(t) { var e = t.host; return e && e.nodeType ? e : t.parentNode } function U(t, e, n) { t.addEventListener(e, n, A) } function z(t, e, n) { t.removeEventListener(e, n, A) } function H(t, e, n) { if (t) if (t.classList)t.classList[n ? 'add' : 'remove'](e); else { var o = (' ' + t.className + ' ').replace(w, ' ').replace(' ' + e + ' ', ' '); t.className = (o + (n ? ' ' + e : '')).replace(w, ' ') } } function V(t, e, n) { var o = t && t.style; if (o) { if (void 0 === n) return T.defaultView && T.defaultView.getComputedStyle ? n = T.defaultView.getComputedStyle(t, '') : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e]; e in o || (e = '-webkit-' + e), o[e] = n + (typeof n === 'string' ? '' : 'px') } } function G(t, e, n) { if (t) { var o = t.getElementsByTagName(e), a = 0, i = o.length; if (n) for (;a < i; a++)n(o[a], a); return o } return [] } function J(t, e, n, a, i, r, s, l) { t = t || e[S]; var c = T.createEvent('Event'), d = t.options, u = 'on' + n.charAt(0).toUpperCase() + n.substr(1); c.initEvent(n, !0, !0), c.to = i || e, c.from = r || e, c.item = a || e, c.clone = o, c.oldIndex = s, c.newIndex = l, e.dispatchEvent(c), d[u] && d[u].call(t, c) } function Q(t, e, n, o, a, i, r, s) { var l, c, d = t[S], u = d.options.onMove; return (l = T.createEvent('Event')).initEvent('move', !0, !0), l.to = e, l.from = t, l.dragged = n, l.draggedRect = o, l.related = a || e, l.relatedRect = i || e.getBoundingClientRect(), l.willInsertAfter = s, t.dispatchEvent(l), u && (c = u.call(d, l, r)), c } function Z(t) { t.draggable = !1 } function K() { P = !1 } function tt(t) { for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; n--;)o += e.charCodeAt(n); return o.toString(36) } function et(t, e) { var n = 0; if (!t || !t.parentNode) return -1; for (;t && (t = t.previousElementSibling);)t.nodeName.toUpperCase() === 'TEMPLATE' || e !== '>*' && !nt(t, e) || n++; return n } function nt(t, e) { if (t) { var n = (e = e.split('.')).shift().toUpperCase(), o = new RegExp('\\s(' + e.join('|') + ')(?=\\s)', 'g'); return !(n !== '' && t.nodeName.toUpperCase() != n || e.length && ((' ' + t.className + ' ').match(o) || []).length != e.length) } return !1 } function ot(t, e) { var n, o; return function () { void 0 === n && (n = arguments, o = this, I(function () { n.length === 1 ? t.call(o, n[0]) : t.apply(o, n), n = void 0 }, e)) } } function at(t, e) { if (t && e) for (var n in e)e.hasOwnProperty(n) && (t[n] = e[n]); return t } function it(t) { return N && N.dom ? N.dom(t).cloneNode(!0) : k ? k(t).clone(!0)[0] : t.cloneNode(!0) } function rt(t) { return I(t, 0) } function st(t) { return clearTimeout(t) } return q.prototype = {constructor: q, _onTapStart: function (e) { var n, o = this, a = this.el, i = this.options, s = i.preventOnFilter, l = e.type, c = e.touches && e.touches[0], d = (c || e).target, u = e.target.shadowRoot && e.path && e.path[0] || d, p = i.filter; if ((function (t) { var e = t.getElementsByTagName('input'), n = e.length; for (;n--;) { var o = e[n]; o.checked && M.push(o) } }(a)), !t && !(/mousedown|pointerdown/.test(l) && e.button !== 0 || i.disabled) && !u.isContentEditable && (d = L(d, i.draggable, a)) && r !== d) { if (n = et(d, i.draggable), typeof p === 'function') { if (p.call(this, e, d, this)) return J(o, u, 'filter', d, a, a, n), void (s && e.preventDefault()) } else if (p && (p = p.split(',').some(function (t) { if (t = L(u, t.trim(), a)) return J(o, t, 'filter', d, a, a, n), !0 }))) return void (s && e.preventDefault()); i.handle && !L(u, i.handle, a) || this._prepareDragStart(e, c, d, n) } }, _prepareDragStart: function (n, o, s, l) { var c, d = this, u = d.el, p = d.options, f = u.ownerDocument; s && !t && s.parentNode === u && (m = n, a = u, e = (t = s).parentNode, i = t.nextSibling, r = s, g = p.group, h = l, this._lastX = (o || n).clientX, this._lastY = (o || n).clientY, t.style['will-change'] = 'all', c = function () { d._disableDelayedDrag(), t.draggable = d.nativeDraggable, H(t, p.chosenClass, !0), d._triggerDragStart(n, o), J(d, a, 'choose', t, a, a, h) }, p.ignore.split(',').forEach(function (e) { G(t, e.trim(), Z) }), U(f, 'mouseup', d._onDrop), U(f, 'touchend', d._onDrop), U(f, 'touchcancel', d._onDrop), U(f, 'selectstart', d), p.supportPointer && U(f, 'pointercancel', d._onDrop), p.delay ? (U(f, 'mouseup', d._disableDelayedDrag), U(f, 'touchend', d._disableDelayedDrag), U(f, 'touchcancel', d._disableDelayedDrag), U(f, 'mousemove', d._disableDelayedDrag), U(f, 'touchmove', d._disableDelayedDrag), p.supportPointer && U(f, 'pointermove', d._disableDelayedDrag), d._dragStartTimer = I(c, p.delay)) : c()) }, _disableDelayedDrag: function () { var t = this.el.ownerDocument; clearTimeout(this._dragStartTimer), z(t, 'mouseup', this._disableDelayedDrag), z(t, 'touchend', this._disableDelayedDrag), z(t, 'touchcancel', this._disableDelayedDrag), z(t, 'mousemove', this._disableDelayedDrag), z(t, 'touchmove', this._disableDelayedDrag), z(t, 'pointermove', this._disableDelayedDrag) }, _triggerDragStart: function (e, n) { (n = n || (e.pointerType == 'touch' ? e : null)) ? (m = {target: t, clientX: n.clientX, clientY: n.clientY}, this._onDragStart(m, 'touch')) : this.nativeDraggable ? (U(t, 'dragend', this), U(a, 'dragstart', this._onDragStart)) : this._onDragStart(m, !0); try { T.selection ? rt(function () { T.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) {} }, _dragStarted: function () { if (a && t) { var e = this.options; H(t, e.ghostClass, !0), H(t, e.dragClass, !1), q.active = this, J(this, a, 'start', t, a, a, h) } else this._nulling() }, _emulateDragOver: function () { if (b) { if (this._lastX === b.clientX && this._lastY === b.clientY) return; this._lastX = b.clientX, this._lastY = b.clientY, B || V(n, 'display', 'none'); var t = T.elementFromPoint(b.clientX, b.clientY), e = t, o = R.length; if (t && t.shadowRoot && (e = t = t.shadowRoot.elementFromPoint(b.clientX, b.clientY)), e) do { if (e[S]) { for (;o--;)R[o]({clientX: b.clientX, clientY: b.clientY, target: t, rootEl: e}); break }t = e } while (e = e.parentNode);B || V(n, 'display', '') } }, _onTouchMove: function (t) { if (m) { var e = this.options, o = e.fallbackTolerance, a = e.fallbackOffset, i = t.touches ? t.touches[0] : t, r = i.clientX - m.clientX + a.x, s = i.clientY - m.clientY + a.y, l = t.touches ? 'translate3d(' + r + 'px,' + s + 'px,0)' : 'translate(' + r + 'px,' + s + 'px)'; if (!q.active) { if (o && X(Y(i.clientX - this._lastX), Y(i.clientY - this._lastY)) < o) return; this._dragStarted() } this._appendGhost(), _ = !0, b = i, V(n, 'webkitTransform', l), V(n, 'mozTransform', l), V(n, 'msTransform', l), V(n, 'transform', l), t.preventDefault() } }, _appendGhost: function () { if (!n) { var e, o = t.getBoundingClientRect(), i = V(t), r = this.options; H(n = t.cloneNode(!0), r.ghostClass, !1), H(n, r.fallbackClass, !0), H(n, r.dragClass, !0), V(n, 'top', o.top - E(i.marginTop, 10)), V(n, 'left', o.left - E(i.marginLeft, 10)), V(n, 'width', o.width), V(n, 'height', o.height), V(n, 'opacity', '0.8'), V(n, 'position', 'fixed'), V(n, 'zIndex', '100000'), V(n, 'pointerEvents', 'none'), r.fallbackOnBody && T.body.appendChild(n) || a.appendChild(n), e = n.getBoundingClientRect(), V(n, 'width', 2 * o.width - e.width), V(n, 'height', 2 * o.height - e.height) } }, _onDragStart: function (e, n) { var i = this, r = e.dataTransfer, s = i.options; i._offUpEvents(), g.checkPull(i, i, t, e) && ((o = it(t)).draggable = !1, o.style['will-change'] = '', V(o, 'display', 'none'), H(o, i.options.chosenClass, !1), i._cloneId = rt(function () { a.insertBefore(o, t), J(i, a, 'clone', t) })), H(t, s.dragClass, !0), n ? (n === 'touch' ? (U(T, 'touchmove', i._onTouchMove), U(T, 'touchend', i._onDrop), U(T, 'touchcancel', i._onDrop), s.supportPointer && (U(T, 'pointermove', i._onTouchMove), U(T, 'pointerup', i._onDrop))) : (U(T, 'mousemove', i._onTouchMove), U(T, 'mouseup', i._onDrop)), i._loopId = setInterval(i._emulateDragOver, 50)) : (r && (r.effectAllowed = 'move', s.setData && s.setData.call(i, r, t)), U(T, 'drop', i), i._dragStartId = rt(i._dragStarted)) }, _onDragOver: function (r) { var s, l, c, h, f = this.el, m = this.options, b = m.group, y = q.active, D = g === b, w = !1, C = m.sort; if (void 0 !== r.preventDefault && (r.preventDefault(), !m.dragoverBubble && r.stopPropagation()), !t.animated && (_ = !0, y && !m.disabled && (D ? C || (h = !a.contains(t)) : v === this || (y.lastPullMode = g.checkPull(this, y, t, r)) && b.checkPut(this, y, t, r)) && (void 0 === r.rootEl || r.rootEl === this.el))) { if (j(r, m, this.el), P) return; if (s = L(r.target, m.draggable, f), l = t.getBoundingClientRect(), v !== this && (v = this, w = !0), h) return F(y, !0), e = a, void (o || i ? a.insertBefore(t, o || i) : C || a.appendChild(t)); if (f.children.length === 0 || f.children[0] === n || f === r.target && (function (t, e) { var n = t.lastElementChild.getBoundingClientRect(); return e.clientY - (n.top + n.height) > 5 || e.clientX - (n.left + n.width) > 5 }(f, r))) { if (f.children.length !== 0 && f.children[0] !== n && f === r.target && (s = f.lastElementChild), s) { if (s.animated) return; c = s.getBoundingClientRect() }F(y, D), !1 !== Q(a, f, t, l, s, c, r) && (t.contains(f) || (f.appendChild(t), e = f), this._animate(l, t), s && this._animate(c, s)) } else if (s && !s.animated && s !== t && void 0 !== s.parentNode[S]) { d !== s && (d = s, u = V(s), p = V(s.parentNode)); var T = (c = s.getBoundingClientRect()).right - c.left, E = c.bottom - c.top, k = x.test(u.cssFloat + u.display) || p.display == 'flex' && p['flex-direction'].indexOf('row') === 0, N = s.offsetWidth > t.offsetWidth, A = s.offsetHeight > t.offsetHeight, O = (k ? (r.clientX - c.left) / T : (r.clientY - c.top) / E) > 0.5, B = s.nextElementSibling, Y = !1; if (k) { var X = t.offsetTop, M = s.offsetTop; Y = X === M ? s.previousElementSibling === t && !N || O && N : s.previousElementSibling === t || t.previousElementSibling === s ? (r.clientY - c.top) / E > 0.5 : M > X } else w || (Y = B !== t && !A || O && A); var R = Q(a, f, t, l, s, c, r, Y); !1 !== R && (R !== 1 && R !== -1 || (Y = R === 1), P = !0, I(K, 30), F(y, D), t.contains(f) || (Y && !B ? f.appendChild(t) : s.parentNode.insertBefore(t, Y ? B : s)), e = t.parentNode, this._animate(l, t), this._animate(c, s)) } } }, _animate: function (t, e) { var n = this.options.animation; if (n) { var o = e.getBoundingClientRect(); t.nodeType === 1 && (t = t.getBoundingClientRect()), V(e, 'transition', 'none'), V(e, 'transform', 'translate3d(' + (t.left - o.left) + 'px,' + (t.top - o.top) + 'px,0)'), e.offsetWidth, V(e, 'transition', 'all ' + n + 'ms'), V(e, 'transform', 'translate3d(0,0,0)'), clearTimeout(e.animated), e.animated = I(function () { V(e, 'transition', ''), V(e, 'transform', ''), e.animated = !1 }, n) } }, _offUpEvents: function () { var t = this.el.ownerDocument; z(T, 'touchmove', this._onTouchMove), z(T, 'pointermove', this._onTouchMove), z(t, 'mouseup', this._onDrop), z(t, 'touchend', this._onDrop), z(t, 'pointerup', this._onDrop), z(t, 'touchcancel', this._onDrop), z(t, 'pointercancel', this._onDrop), z(t, 'selectstart', this) }, _onDrop: function (r) { var s = this.el, l = this.options; clearInterval(this._loopId), clearInterval(D.pid), clearTimeout(this._dragStartTimer), st(this._cloneId), st(this._dragStartId), z(T, 'mouseover', this), z(T, 'mousemove', this._onTouchMove), this.nativeDraggable && (z(T, 'drop', this), z(s, 'dragstart', this._onDragStart)), this._offUpEvents(), r && (_ && (r.preventDefault(), !l.dropBubble && r.stopPropagation()), n && n.parentNode && n.parentNode.removeChild(n), a !== e && q.active.lastPullMode === 'clone' || o && o.parentNode && o.parentNode.removeChild(o), t && (this.nativeDraggable && z(t, 'dragend', this), Z(t), t.style['will-change'] = '', H(t, this.options.ghostClass, !1), H(t, this.options.chosenClass, !1), J(this, a, 'unchoose', t, e, a, h), a !== e ? (f = et(t, l.draggable)) >= 0 && (J(null, e, 'add', t, e, a, h, f), J(this, a, 'remove', t, e, a, h, f), J(null, e, 'sort', t, e, a, h, f), J(this, a, 'sort', t, e, a, h, f)) : t.nextSibling !== i && (f = et(t, l.draggable)) >= 0 && (J(this, a, 'update', t, e, a, h, f), J(this, a, 'sort', t, e, a, h, f)), q.active && (f != null && f !== -1 || (f = h), J(this, a, 'end', t, e, a, h, f), this.save()))), this._nulling() }, _nulling: function () { a = t = e = n = i = o = r = s = l = m = b = _ = f = d = u = v = g = q.active = null, M.forEach(function (t) { t.checked = !0 }), M.length = 0 }, handleEvent: function (e) { switch (e.type) { case 'drop':case 'dragend':this._onDrop(e); break; case 'dragover':case 'dragenter':t && (this._onDragOver(e), (function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = 'move'); t.preventDefault() }(e))); break; case 'mouseover':this._onDrop(e); break; case 'selectstart':e.preventDefault() } }, toArray: function () { for (var t, e = [], n = this.el.children, o = 0, a = n.length, i = this.options; o < a; o++)L(t = n[o], i.draggable, this.el) && e.push(t.getAttribute(i.dataIdAttr) || tt(t)); return e }, sort: function (t) { var e = {}, n = this.el; this.toArray().forEach(function (t, o) { var a = n.children[o]; L(a, this.options.draggable, n) && (e[t] = a) }, this), t.forEach(function (t) { e[t] && (n.removeChild(e[t]), n.appendChild(e[t])) }) }, save: function () { var t = this.options.store; t && t.set(this) }, closest: function (t, e) { return L(t, e || this.options.draggable, this.el) }, option: function (t, e) { var n = this.options; if (void 0 === e) return n[t]; n[t] = e, t === 'group' && $(n) }, destroy: function () { var t = this.el; t[S] = null, z(t, 'mousedown', this._onTapStart), z(t, 'touchstart', this._onTapStart), z(t, 'pointerdown', this._onTapStart), this.nativeDraggable && (z(t, 'dragover', this), z(t, 'dragenter', this)), Array.prototype.forEach.call(t.querySelectorAll('[draggable]'), function (t) { t.removeAttribute('draggable') }), R.splice(R.indexOf(this._onDragOver), 1), this._onDrop(), this.el = t = null }}, U(T, 'touchmove', function (t) { q.active && t.preventDefault() }), q.utils = {on: U, off: z, css: V, find: G, is: function (t, e) { return !!L(t, e, t) }, extend: at, throttle: ot, closest: L, toggleClass: H, clone: it, index: et, nextTick: rt, cancelNextTick: st}, q.create = function (t, e) { return new q(t, e) }, q.version = '1.7.0', q }))
    },
    2156: function (t, e, n) { 'use strict'; var o = n(1524); n.n(o).a },
    2157: function (t, e, n) { (t.exports = n(1139)(!0)).push([t.i, '.taginput-sortable .tag{cursor:grab!important}', '', {version: 3, sources: ['/Users/brianh/repos/test/buefy/docs/pages/extensions/sortablejs/examples/docs/pages/extensions/sortablejs/examples/ExSimple.vue'], names: [], mappings: 'AAmFA,wBACA,qBAAA,CACA', file: 'ExSimple.vue?vue&type=style&index=0&lang=css&', sourcesContent: ["<template>\n    <section>\n        <b-field label=\"What's your favourite food?\">\n            <b-taginput\n                class=\"taginput-sortable\"\n                v-sortable=\"sortableOptions\"\n                v-model=\"tags\"\n                ellipsis\n                icon=\"label\"\n                placeholder=\"Add a food\">\n            </b-taginput>\n        </b-field>\n        <p class=\"content\"><b>Tags:</b> {{ tags }}</p>\n    </section>\n</template>\n\n<script>\n    // You have to install sortable.js to use it:\n    // 'npm install sortablejs'\n    import Sortable from 'sortablejs'\n\n    const createSortable = (el, options, vnode) => {\n        return Sortable.create(el, {\n            ...options,\n            onEnd: function (evt) {\n                const data = vnode.componentInstance.$data.tags\n                const item = data[evt.oldIndex]\n                if (evt.newIndex > evt.oldIndex) {\n                    for (let i = evt.oldIndex; i < evt.newIndex; i++) {\n                        data[i] = data[i + 1]\n                    }\n                } else {\n                    for (let i = evt.oldIndex; i > evt.newIndex; i--) {\n                        data[i] = data[i - 1]\n                    }\n                }\n                data[evt.newIndex] = item\n                vnode.componentInstance.$emit('input', data)\n                vnode.context.$buefy.toast.open(`Moved ${item} from row ${evt.oldIndex + 1} to ${evt.newIndex + 1}`)\n            }\n        })\n    }\n\n    /**\n     * We add a new instance of Sortable when the element\n     * is bound or updated, and destroy it when it's unbound.\n     */\n    const sortable = {\n        name: 'sortable',\n        bind(el, binding, vnode) {\n            const container = el.querySelector('.taginput-container')\n            container._sortable = createSortable(container, binding.value, vnode)\n        },\n        update(el, binding, vnode) {\n            const container = el.querySelector('.taginput-container')\n            container._sortable.destroy()\n            container._sortable = createSortable(container, binding.value, vnode)\n        },\n        unbind(el) {\n            const container = el.querySelector('.taginput-container')\n            container._sortable.destroy()\n        }\n    }\n\n    export default {\n        directives: { sortable },\n        data() {\n            return {\n                sortableOptions: {\n                    chosenClass: 'is-primary',\n                    draggable: '.tag'\n                },\n                tags: [\n                    'Pizza',\n                    'Ice cream',\n                    'Cake'\n                ]\n            }\n        }\n    }\n<\/script>\n\n<style>\n.taginput-sortable .tag {\n  cursor: grab !important;\n}\n</style>\n"], sourceRoot: ''}]) },
    570: function (t, e, n) { 'use strict'; Object.defineProperty(e, '__esModule', {value: !0}); var o = n(2153), a = n(1522), i = (n(2156), n(0)), r = Object(i.a)(a.a, o.a, o.b, !1, null, null, null); e.default = r.exports }})
